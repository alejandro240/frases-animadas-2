# Github Actions

# 1. Qu√® √©s GitHub Actions?

**GitHub Actions** √©s una eina integrada dins de GitHub que permet **automatitzar processos** dins del cicle de vida d‚Äôun projecte de programari.

Aquesta automatitzaci√≥ es coneix com a **CI/CD** (Integraci√≥ Cont√≠nua i Desplegament Cont√≠nu).

<aside>
üîç

### En paraules senzilles:

Podem fer que cada cop que fem un ‚Äúpush‚Äù o un ‚Äúpull request‚Äù al nostre repositori, GitHub executi autom√†ticament una s√®rie de tasques: proves, compilaci√≥, desplegament, notificacions, etc.

</aside>

| Fase | Descripci√≥ | Objectiu |
| --- | --- | --- |
| **CI (Continuous Integration)** | Cada cop que hi ha un canvi al codi, s‚Äôexecuten proves autom√†tiques i validacions. | Detectar errors r√†pidament. |
| **CD (Continuous Deployment)** | Els canvis validads es despleguen autom√†ticament a un servidor o entorn. | Reduir temps i errors humans en el desplegament. |

A la teoria de la AEA anterior ja v√†rem parlar de CI/CD, per√≤ realment nom√©s vam implementar CD (Continuous Deployment). Nosaltres f√®iem un canvi al nostre codi, despr√©s un push al nostre repositori de Github, i gr√†cies que el ten√≠em connectat amb Laravel Cloud el projecte ‚Äúse‚Äôns desplegava sol‚Äù.

El que no f√®iem en la teoria passada era tot el proc√©s de CI (Continuous integration) que b√†sicament serien tests i jocs de proves per detectar errors, i en cas que se‚Äôn produ√Øssin frenar el desplegament.

## 1.1 Per qu√® es fa servir Github Actions?

GitHub Actions serveix per **automatitzar** qualsevol part del flux de desenvolupament:

- ‚úÖ Testar el codi autom√†ticament.
- üöÄ Fer desplegaments autom√†tics (per exemple, a un servidor o a Docker Hub).
- üßπ Revisar el codi o formatar-lo.
- üì¶ Generar versions i publicar releases.
- üîî Notificar equips (Slack, Discord, correu, etc.).

## 1.2 Avantatges principals

1. **Automatitzaci√≥ total del flux de treball**.
    
    (No cal executar scripts manuals per testejar o desplegar.)
    
2. **Integraci√≥ nativa amb GitHub**.
    
    (No cal cap servidor extern com Jenkins o Travis.)
    
3. **Compatibilitat multi-entorn**.
    
    (Linux, Windows, macOS, contenidors Docker, etc.)
    
4. **Facilitat d‚Äôescalat i reutilitzaci√≥**.
    
    (Podem crear *workflows* i *actions* personalitzades reutilitzables.)
    
5. **Auditoria i transpar√®ncia**.
    
    (Cada execuci√≥ queda registrada, amb logs i estat d‚Äô√®xit/error.)
    

## 1.3 Components b√†sics d‚Äôun *workflow*

Un *workflow* √©s un fitxer YAML situat a:

```bash
.github/workflows/nom_del_workflow.yml
```

Aquest √©s un arxiu ocult (la ruta est√† oculta amb el **`.`**) i nom√©s l‚Äôentendr√† Github. Aqu√≠ dins escriurem les instruccions que volem que executi Github Actions.

### 1.3.1 Elements principals:

| Element | Descripci√≥ |
| --- | --- |
| `name:` | Nom del workflow |
| `on:` | Esdeveniments que l‚Äôactiven (push, pull_request, schedule...) |
| `jobs:` | Llistat de feines a executar |
| `runs-on:` | Sistema operatiu o entorn (ubuntu-latest, windows-latest, etc.) |
| `steps:` | Passos que s‚Äôexecuten dins d‚Äôun job |
| `uses:` | Fa servir una *action* preconstru√Øda |
| `run:` | Executa comandes directament |

## 1.4 Exemples d‚Äôesdeveniments que activen un workflow

Un workflow √©s un conjunt de tasques autom√†tiques que s'executen en funci√≥ de certs esdeveniments que ocorren en el repositori. Els esdeveniments s√≥n accions espec√≠fiques que passen a GitHub, com un ***push*** (quan es fa un canvi al codi), un ***pull request*** (quan es sol¬∑licita unir canvis a una branca), o fins i tot esdeveniments programats.

```yaml
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ develop ]
  schedule:
    - cron: '0 8 * * *' # Cada dia a les 8:00
```

### 1. **`push`**

Aquest esdeveniment s'activa quan es fa un ***push*** de codi a una branca del repositori. Per exemple, quan realitzes un canvi local en el teu projecte i el pujes a GitHub mitjan√ßant `git push`. El workflow es pot configurar perqu√® s'executi nom√©s en determinades branques.

Aix√≤ vol dir que **nom√©s s'executar√† el workflow quan es faci un push a la branca `main`**. Aix√≠, si fas un `push` a altres branques com `develop` o `feature-branch`, el workflow no s'activar√†. Aquesta configuraci√≥ √©s √∫til per assegurar que el workflow nom√©s es dispara quan els canvis es fan en una branca espec√≠fica (en aquest cas, `main`).

### 2. **`pull_request`**

Aquest esdeveniment s'activa quan es crea o actualitza un **pull request**. Un pull request √©s una petici√≥ per integrar els canvis d'una branca (per exemple, `feature-branch`) a una altra (per exemple, `main` o `develop`). Aquesta acci√≥ √©s molt √∫til per garantir que els canvis proposats en un pull request siguin verificats mitjan√ßant proves autom√†tiques abans de ser fusionats amb la branca principal.

En aquest cas, el workflow s'executar√† quan es cre√Ø o actualitzi un ***pull request*** que vagi a la branca `develop`. Aix√≤ √©s √∫til per validar que els canvis que s'introdueixen en un ***pull request*** no trenquin res abans de fusionar-los a la branca de desenvolupament.

### 3. **`schedule`**

Aquesta acci√≥ s'activa segons un **horari programat**. Es pot utilitzar un format `cron` per definir quan vols que s'executi el workflow. Aix√≤ permet executar processos automatitzats de manera peri√≤dica, independentment de les accions dels usuaris.

Aquest cronograma indica que el workflow es realitzar√† **cada dia a les 8:00 AM**. Els crons segueixen una sintaxi est√†ndard que es compon de cinc camps que representen (en ordre): minut, hora, dia del mes, mes, dia de la setmana. En aquest cas, `0 8 * * *` vol dir "a les 8:00 AM cada dia".

Aquesta funcionalitat √©s √∫til per a tasques de manteniment peri√≤diques, com ara la neteja de la base de dades, l'enviament de correus electr√≤nics autom√†tics o l'execuci√≥ de proves programades.

## 1.5 Alternatives a Github Actions

![[Jenkins](https://www.jenkins.io/)](attachment:9482eca3-ef25-4d2a-86e6-de57b12aea7c:image.png)

[Jenkins](https://www.jenkins.io/)

![[Gitlab CI/CD](https://about.gitlab.com/solutions/continuous-integration/)](attachment:1f2c93cc-6648-432b-8ab2-4b13710f8bfb:image.png)

[Gitlab CI/CD](https://about.gitlab.com/solutions/continuous-integration/)

![[Bitbucket Pipelines](https://www.atlassian.com/software/bitbucket/features/pipelines)](attachment:125aa0c0-3e5b-42cc-a344-94d0aa4d74eb:image.png)

[Bitbucket Pipelines](https://www.atlassian.com/software/bitbucket/features/pipelines)

![[Circle CI](https://circleci.com/)](attachment:7e4c5802-ab01-44e3-83b1-55e112759c9c:image.png)

[Circle CI](https://circleci.com/)

# 2. Exemple de CI/CD amb Github actions

## 2.1 Prerequisits

- **PHP 8.2+**
- **Composer**
- **SQLite** (ve incorporat amb PHP habitualment)
- (Opcional) **Git** i un compte de **GitHub**

<aside>
üí°

No farem front-end ni Vite per simplificar. Ens centrarem en backend + tests.

</aside>

## 2.2 Crear el projecte Laravel i executar-lo en local

Creem un nou projecte anomenat **laravel-ci-demo**:

```bash
composer create-project laravel/laravel laravel-ci-demo
```

Posem en marxa el projecte

```bash
php artisan serve
```

Obrim `http://127.0.0.1:8000` i comprovem que carrega la portada de Laravel.

## 2.3 Mini funcionalitat: Llista de tasques (Task)

Crearem un CRUD molt b√†sic: **llistar** i **crear** tasques, i **marcar/desmarcar** com a fetes.

```bash
php artisan make:model Task -mcr
```

Aix√≤ crea:

- Model: `app/Models/Task.php`
- Migraci√≥: `database/migrations/xxxx_xx_xx_xxxxxx_create_tasks_table.php`
- Controlador: `app/Http/Controllers/TaskController.php` (resource)

## 2.4 Migraci√≥ `create_tasks_table`

Obre el fitxer de migraci√≥ creat i substitueix el contingut per:

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration {
    public function up(): void
    {
        Schema::create('tasks', function (Blueprint $table) {
            $table->id();
            $table->string('title');
            $table->boolean('done')->default(false);
            $table->timestamps();
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('tasks');
    }
};
```

Aplica migracions:

```bash
php artisan migrate
```

## 2.5 Model `Task.php`

Editem el model i fem ‚Äúassignable‚Äù (*fillable*) els camps que voldrem anar modificant:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Task extends Model
{
    protected $fillable = ['title', 'done'];
}
```

## 2.6 Controlador `TaskController.php`

Del controlador de recursos aprofitarem els m√®todes `index` i `store` i crearem el m√®tode `toggle` per canviar l‚Äôestat d‚Äôuna tasca.

```php
<?php

namespace App\Http\Controllers;

use App\Models\Task;
use Illuminate\Http\Request;

class TaskController extends Controller
{
    public function index()
    {
        $tasks = Task::latest()->get();
        return view('tasks.index', compact('tasks'));
    }

    public function store(Request $request)
    {
        $data = $request->validate([
            'title' => ['required','string','max:255'],
        ]);

        Task::create($data);
        return redirect()->route('tasks.index');
    }

    public function toggle(Task $task)
    {
        $task->update(['done' => ! $task->done]);
        return redirect()->route('tasks.index');
    }
}
```

## 2.7 Rutes

Editem l‚Äôarxiu de rutes per encaminar les 3 possibles peticions:

- Llistar totes les tasques
- Crear una tasca nova
- Canviar l‚Äôestat d‚Äôuna tasca

```php
<?php

use App\Http\Controllers\TaskController;
use Illuminate\Support\Facades\Route;

Route::get('/', [TaskController::class, 'index'])->name('tasks.index');
Route::post('/tasks', [TaskController::class, 'store'])->name('tasks.store');
Route::patch('/tasks/{task}/toggle', [TaskController::class, 'toggle'])->name('tasks.toggle');
```

## 2.8 Vista molt simple

Crea `resources/views/tasks/index.blade.php`:

```html
<!doctype html>
<html lang="ca">
<head>
  <meta charset="utf-8">
  <title>Task Demo</title>
  <!-- Per simplicitat, style m√≠nim inline -->
  <style>
    body { font-family: system-ui, sans-serif; max-width: 720px; margin: 2rem auto; }
    form { margin: 1rem 0; display: flex; gap: .5rem; }
    input[type=text]{ flex:1; padding:.5rem; }
    button { padding:.5rem 1rem; }
    ul{list-style:none; padding:0; margin:1rem 0;}
    li{ display:flex; justify-content:space-between; border:1px solid #ddd; padding:.5rem; margin:.25rem 0; border-radius: .375rem;}
    .done { text-decoration: line-through; color: #666; }
  </style>
</head>
<body>
  <h1>üìã Llista de tasques</h1>

  <form method="POST" action="{{ route('tasks.store') }}">
    @csrf
    <input type="text" name="title" placeholder="Nova tasca..." required>
    <button type="submit">Afegir</button>
  </form>

  @error('title')
    <p style="color:#c00">{{ $message }}</p>
  @enderror

  <ul>
    @forelse($tasks as $task)
      <li>
        <span class="{{ $task->done ? 'done' : '' }}">{{ $task->title }}</span>
        <form method="POST" action="{{ route('tasks.toggle', $task) }}">
          @csrf @method('PATCH')
          <button type="submit">{{ $task->done ? 'Desfer' : 'Fet' }}</button>
        </form>
      </li>
    @empty
      <li>No hi ha tasques encara.</li>
    @endforelse
  </ul>
</body>
</html>
```

Ara ho testegem en local

```bash
php artisan serve
```

Afegeix una tasca, marca/desmarca com a feta. 

![image.png](attachment:bd1b9828-e213-4e83-89a9-7ff715af1641:image.png)

## 2.9 Afegir tests b√†sics (per a la CI)

Al principi de la teoria hem dit que la integraci√≥ cont√≠nua:

> Cada cop que hi ha un canvi al codi, s‚Äôexecuten proves autom√†tiques i validacions.
> 

De moment mai hem creat cap tipus de test, ni unitari ni de caracter√≠stiques. Aix√≤ acostuma a ser teoria d‚Äôaltres assignatures. Ara, per√≤, crearem un senzill test de caracter√≠stiques per veure si es compleix quelcom que ja intu√Øm que s√≠ perqu√® ho hem provat en el punt anterior. Per√≤ val la pena crear-los i imaginar que s√≥n tests molt m√©s complexos i els farem servir per il¬∑lustrar aquest apartat.

Crearem un test de caracter√≠stica senzill.

```bash
php artisan make:test TaskTest
```

Edita `tests/Feature/TaskTest.php`:

```php
<?php

namespace Tests\Feature;

use App\Models\Task;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class TaskTest extends TestCase
{
    use RefreshDatabase;

    public function test_the_homepage_loads()
    {
        $this->get('/')->assertStatus(200)->assertSee('Llista de tasques');
    }

    public function test_we_can_create_a_task()
    {
        $response = $this->post('/tasks', ['title' => 'Provar CI']);
        $response->assertRedirect('/');
        $this->assertDatabaseHas('tasks', ['title' => 'Provar CI', 'done' => false]);
    }

    public function test_we_can_toggle_a_task()
    {
        $task = Task::create(['title' => 'Tasca', 'done' => false]);

        // Comprova que la tasca inicialment no est√† feta
        $this->assertFalse($task->done);

        $this->patch("/tasks/{$task->id}/toggle")->assertRedirect('/');

        // Actualitza la tasca
        $task = $task->fresh();

        //vull saber si el camp done √©s 1 o 0 a la base de dades
        $this->assertDatabaseHas('tasks', ['id' => $task->id, 'done' => true]);
    }
}
```

<aside>
üí°

Totes les funcions de test han de comen√ßar amb el sufix `test_`, per exemple `test_we_can_toggle_a_task()`

</aside>

Executa‚Äôls en local:

```bash
php artisan test
```

<aside>
üí°

Els tests haurien de sortir positius. Si trobes errors √©s possible que sigui per culpa dels tests d‚Äôexemple. Esborra‚Äôls o comenta‚Äôls.

</aside>

<aside>
‚ö†Ô∏è

Alerta! Si esborres els tests d‚Äôexemple (sobretot els tests unitaris) t‚Äôhas d‚Äôassegurar que l‚Äôarxiu `phpunit.xml` no els busqui a la ruta on haurien d‚Äôestar:

![image.png](attachment:044c94db-3f33-40ea-876b-e98d8521cd42:image.png)

</aside>

## 2.10 Inicialitzar el repo i pujar-ho a GitHub

Crearem un nou repositori a Github per aquest projecte:

![image.png](attachment:8eb3f4e1-7e5c-49ab-996e-d5060339eaae:image.png)

Ara dins el nostre projecte farem:

```bash
git init
```

```bash
git add .
```

```bash
git commit -m "Creaci√≥ del porjecte d'exemple de CI amb Laravel"
```

Creem la branca `main` per emparellar la nomenclatura amb Github:

```bash
git branch -M main
```

Ara emparellem el nostre repositori local amb el repositori remot:

```bash
git remote add origin https://github.com/adalmau/laravel-ci-demo.git
```

<aside>
‚ö†Ô∏è

Recorda canviar la ruta per la teva pr√≤pia ruta

</aside>

Finalment fem el `push`:

```bash
git push -u origin main
```

## 2.11 Afegir GitHub Actions (CI b√†sica)

A continuaci√≥ crearem un workflow molt b√†sic que:

1. Fa **checkout** del codi
2. Instal¬∑la **PHP 8.2** i extensions
3. Copia `.env`, crea la BD SQLite
4. Fa **migrate**
5. Executa **tests**

Primer crearem a l‚Äôarrel del nostre projecte el fitxer `.github/workflows/ci.yml`.

<aside>
‚ö†Ô∏è

Molt probablement no existeix la ruta `.github/workflows`, l‚Äôhaur√†s de crear.

</aside>

```yaml
# Nom "hum√†" del workflow. Aix√≠ √©s com el veurem a la pestanya Actions.
name: CI (Laravel)

# Bloc que defineix QUAN s‚Äôexecuta el workflow.
on:
  # 1) Es dispara en fer push...
  push:
    # ...per√≤ nom√©s si el push va a la branca 'main'.
    # YAML permet arrays en una sola l√≠nia: [ main ] √©s equivalent a una llista amb un element.
    branches: [ main ]
  # 2) Tamb√© es dispara quan s‚Äôobre/actualitza un pull request.
  # No especifiquem branques aqu√≠, per tant s‚Äôaplica a PRs entre qualsevol branca.
  pull_request:

# Bloc de feines (jobs) que s‚Äôexecutaran.
jobs:
  # Definim un job anomenat 'tests' (el nom √©s lliure; aqu√≠ indica que far√† proves).
  tests:
    # Indiquem a GitHub quin tipus de m√†quina virtual ha d‚Äôusar.
    # 'ubuntu-latest' √©s l‚Äô√∫ltim Ubuntu que ofereix GitHub (normalment la millor opci√≥ per PHP).
    runs-on: ubuntu-latest

    # Llista ordenada de passos dins del job 'tests'.
    steps:
      # Pas 1: descarregar el codi del repositori al runner.
      - name: Checkout
        # 'uses' vol dir que fem servir una "action" p√∫blica del Marketplace.
        # actions/checkout@v4 clona el repo a la m√†quina del job.
        uses: actions/checkout@v4

      # Pas 2: instal¬∑lar PHP i extensions necess√†ries per a Laravel.
      - name: Set up PHP
        # Action espec√≠fica per gestionar versions/ext dels PHP Runtimes.
        uses: shivammathur/setup-php@v2
        # 'with' passa par√†metres a l'action.
        with:
          # Versi√≥ de PHP que volem al runner.
          php-version: '8.2'
          # Llista d‚Äôextensions que necessitem al projecte.
          # mbstring i bcmath s√≥n habituals a Laravel; pdo_sqlite per fer tests amb SQLite.
          extensions: mbstring, bcmath, pdo_sqlite
          # Desactivem la cobertura (xdebug) per fer el job m√©s r√†pid.
          coverage: none

      # Pas 3: cachejar el directori 'vendor' perqu√® els 'composer install' siguin molt m√©s r√†pids
      # a execucions futures si no canvia el lockfile.
      - name: Cache Composer
        uses: actions/cache@v4
        with:
          # 'path' indica qu√® volem cachejar: el directori de depend√®ncies PHP.
          path: vendor
          # 'key' identifica la "clau" del cache. Si canvia, es crea un cache nou.
          # Fem servir una expressi√≥ de GitHub ${{ ... }} per construir la clau.
          # Afegim el sistema operatiu i el hash del composer.lock (si canvia, el cache deixa de servir).
          key: ${{ runner.os }}-php-${{ hashFiles('**/composer.lock') }}

      # Pas 4: instal¬∑lar les depend√®ncies de Composer del projecte.
      - name: Install Composer dependencies
        # 'run' executa una comanda de shell a la m√†quina del job.
        # --no-progress: menys soroll als logs
        # --prefer-dist: baixa paquets ja empaquetats (m√©s r√†pid)
        # --optimize-autoloader: millora el temps de c√†rrega en producci√≥/CI
        run: composer install --no-progress --prefer-dist --optimize-autoloader

      # Pas 5: preparar l‚Äôentorn de proves.
      - name: Prepare environment
        # El tub '|' indica "multil√≠nia": executarem aquestes comandes, una rere l‚Äôaltra, al mateix pas.
        run: |
          # 5.1 Copiem l'exemple d'entorn a .env (a CI no exposem secrets; usem defaults).
          cp .env.example .env
          # 5.2 Generem l‚ÄôAPP_KEY necess√†ria per a Laravel (encriptaci√≥, sessions, etc.).
          php artisan key:generate
          # 5.3 Creem la base de dades SQLite (fitxer buit). Ideal per a tests en CI.
          touch database/database.sqlite
          # 5.4 Apliquem migracions perqu√® les taules existeixin abans de provar.
          # --force evita que Artisan demani confirmaci√≥ en entorns no interactius.
          php artisan migrate --force

      # Pas 6: executar els tests de Laravel.
      - name: Run tests
        # --no-coverage: no calculem cobertura (m√©s r√†pid per a una demo b√†sica).
        # (Laravel invoca PHPUnit o Pest segons la config del projecte.)
        run: php artisan test --no-coverage

```

Ara aquest fitxer que encara no est√† trackejat per Git l‚Äôhaurem de trackejar i pujar-lo tamb√© al repositori remot:

```bash
git add .
```

```bash
git commit -m "Afegim el fitxer de Github Actions"
```

```bash
git push -u origin main
```

Ara a GitHub ‚Üí pestanya **Actions** veur√†s el workflow corrent en cada *push* o *pull request*.

![image.png](attachment:4437847a-eecc-46e0-a5cc-43ab3ae16544:image.png)

La imatge il¬∑lustra 4 ***push***, 3 dels quals han patit algun tipus d‚Äôerror i el quart ha funcionat correctament.

# 3. Conclusions

Si hem arribat aqu√≠ √©s que tot ha funcionat, per√≤ anem a veure qu√® hem fet i com ho hem fet.

## 3.1 Qu√® hem fet?

GitHub Actions ha estat utilitzat en aquest cas per implementar una soluci√≥ d'integraci√≥ cont√≠nua (CI) i ha millorat el proc√©s de desenvolupament de diverses maneres.

1. **Automatitzaci√≥ de les tasques**: En integrar GitHub Actions al flux de treball, qualsevol canvi realitzat al codi (com un push o pull request) activa autom√†ticament una s√®rie de tasques, com la instal¬∑laci√≥ de depend√®ncies, la configuraci√≥ de l'entorn, les migracions de base de dades i l'execuci√≥ de proves. Aix√≤ elimina la necessitat de realitzar manualment aquestes tasques cada cop que es fa un canvi, el que estalvia temps i minimitza errors humans.
2. **Validaci√≥ cont√≠nua del codi (CI)**: Gr√†cies a les accions configurades, el sistema realitza proves autom√†tiques (tests) sobre el codi cada vegada que es fa un canvi al repositori. Aix√≤ ajuda a detectar errors r√†pidament abans de desplegar els canvis, millorant la qualitat del codi i evitant que errors es propaguin a l'entorn de producci√≥.
3. **Escalabilitat i reutilitzaci√≥**: GitHub Actions √©s molt flexible i permet crear fluxos de treball (workflows) personalitzats, que es poden reutilitzar en altres projectes. Aix√≤ facilita l'escalabilitat del sistema a mesura que els projectes creixen o es requereixen canvis a la infraestructura

## 3.2 Com ho hem fet?

Hem escrit un seguit d‚Äôinstruccions (les **actions**) en un fitxer `.yaml` que interpreta Github:

- **En el *runner* de GitHub Actions**: Els passos de configuraci√≥ de PHP i extensions no es realitzen en el teu entorn local o en el servidor de producci√≥. S√≥n realitzats dins de l'entorn virtual proporcionat per GitHub Actions, que s'anomena *runner*. El *runner* √©s una m√†quina virtual que GitHub crea per a executar els teus workflows.
- Aquest entorn √©s temporal, de manera que cada cop que es fa un ***push*** o un ***pull request*** que activa el workflow, GitHub crea una nova m√†quina virtual (*runner*), realitza tots els passos (inclosa la instal¬∑laci√≥ de PHP i extensions) i despr√©s el descarta un cop finalitzada l'execuci√≥ del workflow.

## 3.3 Qu√® ens ha faltat fer?

**Desplegament autom√†tic (CD)**: En cas que les proves siguin correctes, GitHub Actions tamb√© facilita el desplegament autom√†tic del codi a un servidor de producci√≥. Aix√≤ garanteix que les actualitzacions arribin a producci√≥ sense demora i de forma fiable, amb un proc√©s transparent i auditable.

Ara mateix, tant si els tests fallen com si no, quan fem ***push*** posem al repositori remot el projecte. Estaria b√© condicionar el futur desplegament a si els tests funcionen correctament.